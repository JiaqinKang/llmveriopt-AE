{
  "0": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @faki(...)\n\n@faki = constant ? bytes, exec, align 8\n\ndefine i64 @bikoeff(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#5 = load i32, ptr %#4, align 4\n  %#6 = call i32 @faki(...noundef i32 %#5)\n  %#7 = load i32, ptr %#3, align 4\n  %#8 = call i32 @faki(...noundef i32 %#7)\n  %#9 = sdiv i32 %#6, %#8\n  %#10 = load i32, ptr %#4, align 4\n  %#11 = load i32, ptr %#3, align 4\n  %#12 = sub nsw i32 %#10, %#11\n  %#13 = call i32 @faki(...noundef i32 %#12)\n  %#14 = mul nsw i32 %#9, %#13\n  %#15 = sext i32 %#14 to i64\n  ret i64 %#15\n}\n=>\ndeclare i32 @faki(...)\n\n@faki = constant ? bytes, exec, align 8\n\ndefine i64 @bikoeff(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = call i32 @faki(...noundef i32 noundef %#1)\n  %#4 = call i32 @faki(...noundef i32 noundef %#0)\n  %#5 = sdiv i32 %#3, %#4\n  %#6 = sub nsw i32 noundef %#1, noundef %#0\n  %#7 = call i32 @faki(...noundef i32 %#6)\n  %#8 = mul nsw i32 %#5, %#7\n  %#9 = sext i32 %#8 to i64\n  ret i64 %#9\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 32,
    "tgt_latency": 14,
    "src_size": 164,
    "tgt_size": 168,
    "src_inst": 16,
    "tgt_inst": 8
  },
  "1": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare {float, float} @foo_float(noundef i32) nofree willreturn memory(read)\n\ndefine void @baz_float(ptr noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#2, align 8\n  %#3 = call {float, float} @foo_float(noundef i32 5) nofree willreturn memory(read)\n  %#5 = extractvalue {float, float} %#3, 1\n  %#6 = load ptr, ptr %#2, align 8\n  store float %#5, ptr %#6, align 4\n  ret void\n}\n=>\ndeclare {float, float} @foo_float(noundef i32) nofree willreturn memory(read)\n\ndefine void @baz_float(ptr noundef %#0) {\n#1:\n  %#2 = call {float, float} @foo_float(noundef i32 5) nofree willreturn memory(read)\n  %#3 = extractvalue {float, float} %#2, 1\n  store float %#3, ptr noundef %#0, align 4\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 9,
    "tgt_latency": 4,
    "src_size": 108,
    "tgt_size": 108,
    "src_inst": 8,
    "tgt_inst": 4
  },
  "2": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i128 @foo17003(i128 noundef %#0) {\n#1:\n  %#2 = alloca i64 16, align 16\n  store i128 noundef %#0, ptr %#2, align 16\n  %#3 = load i128, ptr %#2, align 16\n  %#4 = udiv i128 %#3, 7003\n  ret i128 %#4\n}\n=>\ndefine i128 @foo17003(i128 noundef %#0) {\n#1:\n  %#2 = udiv i128 noundef %#0, 7003\n  ret i128 %#2\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 10,
    "tgt_latency": 5,
    "src_size": 136,
    "tgt_size": 96,
    "src_inst": 5,
    "tgt_inst": 2
  },
  "3": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i64 @fll(i64 noundef %#0, i64 noundef %#1) {\n#2:\n  %#3 = alloca i64 8, align 8\n  %#4 = alloca i64 8, align 8\n  store i64 noundef %#0, ptr %#3, align 8\n  store i64 noundef %#1, ptr %#4, align 8\n  %#5 = load i64, ptr %#3, align 8\n  %#6 = and i64 %#5, -1048576\n  %#7 = load i64, ptr %#4, align 8\n  %#8 = shl i64 %#7, 0\n  %#9 = and i64 %#8, 1048575\n  %#10 = or i64 %#6, %#9\n  store i64 %#10, ptr %#3, align 8\n  %#11 = load i64, ptr %#3, align 8\n  ret i64 %#11\n}\n=>\ndefine i64 @fll(i64 noundef %#0, i64 noundef %#1) {\n#2:\n  %#3 = and i64 noundef %#0, -1048576\n  %#4 = shl i64 noundef %#1, 0\n  %#5 = and i64 %#4, 1048575\n  %#6 = or i64 %#3, %#5\n  ret i64 %#6\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 20,
    "tgt_latency": 5,
    "src_size": 100,
    "tgt_size": 60,
    "src_inst": 13,
    "tgt_inst": 5
  },
  "4": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @restore(noundef i32, noundef i32)\n\ndefine void @do_nothing(ptr noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#2, align 8\n  %#3 = load ptr, ptr %#2, align 8\n  %#4 = load i32, ptr %#3, align 4\n  %#5 = call i32 @restore(noundef i32 %#4, noundef i32 1)\n  %#6 = load ptr, ptr %#2, align 8\n  store i32 %#5, ptr %#6, align 4\n  ret void\n}\n=>\ndeclare i32 @restore(noundef i32, noundef i32)\n\ndefine void @do_nothing(ptr noundef %#0) {\n#1:\n  %#2 = load i32, ptr noundef %#0, align 4\n  %#3 = call i32 @restore(noundef i32 %#2, noundef i32 1)\n  store i32 %#3, ptr noundef %#0, align 4\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 18,
    "tgt_latency": 9,
    "src_size": 116,
    "tgt_size": 112,
    "src_inst": 8,
    "tgt_inst": 4
  },
  "5": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare ptr @my_alloc2(noundef i32, noundef i32)\n\ndefine i32 @test6(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  %#5 = alloca i64 4, align 4\n  %#6 = alloca i64 8, align 8\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#7 = load i32, ptr %#4, align 4\n  %#8 = load i32, ptr %#3, align 4\n  %#9 = call ptr @my_alloc2(noundef i32 %#7, noundef i32 %#8)\n  %#10 = zext i32 %#7 to i64\n  assume_align ptr %#9, i64 %#10\n  store ptr %#9, ptr %#6, align 8\n  %#11 = load ptr, ptr %#6, align 8\n  %#12 = ptrtoint ptr %#11 to i64\n  %#13 = and i64 %#12, 15\n  %#14 = trunc i64 %#13 to i32\n  ret i32 %#14\n}\n=>\ndeclare ptr @my_alloc2(noundef i32, noundef i32)\n\ndefine i32 @test6(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = call ptr @my_alloc2(noundef i32 noundef %#1, noundef i32 noundef %#0)\n  %#4 = zext i32 noundef %#1 to i64\n  assume_align ptr %#3, i64 %#4\n  %#5 = ptrtoint ptr %#3 to i64\n  %#6 = and i64 %#5, 15\n  %#7 = trunc i64 %#6 to i32\n  ret i32 %#7\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 20,
    "tgt_latency": 5,
    "src_size": 124,
    "tgt_size": 112,
    "src_inst": 17,
    "tgt_inst": 7
  },
  "6": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare ptr @frnn1() nonnull\ndeclare void @foo()\n\ndefine void @frnn_local_local() {\n#0:\n  %#3 = call ptr @frnn1() nonnull\n  %#4 = icmp ne ptr %#3, null\n  br i1 %#4, label %#2, label %#1\n\n#1:\n  call void @foo()\n  br label %#2\n\n#2:\n  ret void\n}\n=>\ndeclare ptr @frnn1() nonnull\ndeclare void @foo()\n\ndefine void @frnn_local_local() {\n#0:\n  %#3 = call ptr @frnn1() nonnull\n  %#4 = icmp ne ptr %#3, null\n  br i1 %#4, label %#2, label %#1\n\n#1:\n  call void @foo()\n  br label %#2\n\n#2:\n  ret void\n}\nTransformation seems to be correct! (syntactically equal)\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 6,
    "tgt_latency": 6,
    "src_size": 100,
    "tgt_size": 100,
    "src_inst": 6,
    "tgt_inst": 6
  },
  "7": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare double @pow(noundef double, noundef double)\n\ndefine double @test3b(double noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store double noundef %#0, ptr %#2, align 8\n  %#3 = load double, ptr %#2, align 8\n  %#4 = call double @pow(noundef double %#3, noundef double -1.666667)\n  ret double %#4\n}\n=>\ndeclare double @pow(noundef double, noundef double)\n\ndefine double @test3b(double noundef %#0) {\n#1:\n  %#2 = call double @pow(noundef double noundef %#0, noundef double -1.666667)\n  ret double %#2\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 7,
    "tgt_latency": 2,
    "src_size": 116,
    "tgt_size": 100,
    "src_inst": 5,
    "tgt_inst": 2
  },
  "8": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare ptr @memchr(noundef ptr, noundef i32, noundef i64)\n\n@.str = constant 2 bytes, align 1\n\ndefine i32 @f(i8 noundef %#0) {\n#1:\n  %#2 = alloca i64 1, align 1\n  store i8 noundef %#0, ptr %#2, align 1\n  %#3 = load i8, ptr %#2, align 1\n  %#4 = zext i8 %#3 to i32\n  %#5 = call ptr @memchr(noundef ptr @.str, noundef i32 %#4, noundef i64 1) nofree noundef nothrow willreturn memory(argmem: read)\n  %#6 = icmp eq ptr %#5, null\n  %#7 = zext i1 %#6 to i32\n  ret i32 %#7\n}\n=>\ndeclare ptr @memchr(noundef ptr, noundef i32, noundef i64)\n\n@.str = constant 2 bytes, align 1\n\ndefine i32 @f(i8 noundef %#0) {\n#1:\n  %#2 = zext i8 noundef %#0 to i32\n  %#3 = call ptr @memchr(nonnull noundef ptr @.str, noundef i32 %#2, noundef i64 1) nofree noundef nothrow willreturn memory(argmem: read)\n  %#4 = icmp eq ptr %#3, null\n  %#5 = zext i1 %#4 to i32\n  ret i32 %#5\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 12,
    "tgt_latency": 8,
    "src_size": 124,
    "tgt_size": 112,
    "src_inst": 8,
    "tgt_inst": 5
  },
  "9": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i32 @f4(ptr noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#2, align 8\n  %#3 = load ptr, ptr %#2, align 8\n  %#4 = gep inbounds ptr %#3, 1 x i64 0\n  %#5 = load i8, ptr %#4, align 1\n  %#6 = zext i8 %#5 to i32\n  %#7 = shl i32 1, %#6\n  %#8 = xor i32 %#7, 4294967295\n  ret i32 %#8\n}\n=>\ndefine i32 @f4(ptr noundef %#0) {\n#1:\n  %#2 = gep inbounds ptr noundef %#0, 1 x i64 0\n  %#3 = load i8, ptr %#2, align 1\n  %#4 = zext i8 %#3 to i32\n  %#5 = shl i32 1, %#4\n  %#6 = xor i32 %#5, 4294967295\n  ret i32 %#6\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 12,
    "tgt_latency": 7,
    "src_size": 84,
    "tgt_size": 60,
    "src_inst": 9,
    "tgt_inst": 6
  },
  "10": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i16 @test_u16_8_255(i16 noundef %#0) {\n#1:\n  %#2 = alloca i64 2, align 2\n  store i16 noundef %#0, ptr %#2, align 2\n  %#3 = load i16, ptr %#2, align 2\n  %#4 = bswap i16 %#3\n  %#5 = zext i16 %#4 to i32\n  %#6 = ashr i32 %#5, 8\n  %#7 = and i32 %#6, 255\n  %#8 = trunc i32 %#7 to i16\n  ret i16 %#8\n}\n=>\ndefine i16 @test_u16_8_255(i16 noundef %#0) {\n#1:\n  %#2 = bswap i16 noundef %#0\n  %#3 = zext i16 %#2 to i32\n  %#4 = ashr i32 %#3, 8\n  %#5 = and i32 %#4, 255\n  %#6 = trunc i32 %#5 to i16\n  ret i16 %#6\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 10,
    "tgt_latency": 5,
    "src_size": 84,
    "tgt_size": 60,
    "src_inst": 9,
    "tgt_inst": 6
  },
  "11": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpruotafi9.ll'\n/tmp/tmpruotafi9.ll:3:17: error: use of undefined value '@foo'\n  %1 = call i32 @foo()\n                ^",
    "src_latency": 9,
    "tgt_latency": 9,
    "src_size": 92,
    "tgt_size": 92,
    "src_inst": 9,
    "tgt_inst": 9
  },
  "12": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine void @orit(ptr noundef %#0, ptr noundef %#1) {\n#2:\n  %#3 = alloca i64 8, align 8\n  %#4 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#3, align 8\n  store ptr noundef %#1, ptr %#4, align 8\n  %#5 = load ptr, ptr %#3, align 8\n  %#6 = gep inbounds ptr %#5, 8 x i32 0, 1 x i64 0\n  %#7 = load i64, ptr %#6, align 8\n  %#8 = load ptr, ptr %#4, align 8\n  %#9 = gep inbounds ptr %#8, 8 x i32 0, 1 x i64 0\n  %#10 = load i64, ptr %#9, align 8\n  %#11 = or i64 %#10, %#7\n  store i64 %#11, ptr %#9, align 8\n  ret void\n}\n=>\ndefine void @orit(ptr noundef %#0, ptr noundef %#1) {\n#2:\n  %#3 = gep inbounds ptr noundef %#0, 8 x i64 0, 1 x i64 0\n  %#4 = load i64, ptr %#3, align 8\n  %#5 = gep inbounds ptr noundef %#1, 8 x i64 0, 1 x i64 0\n  %#6 = load i64, ptr %#5, align 8\n  %#7 = or i64 %#6, %#4\n  store i64 %#7, ptr %#5, align 8\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 21,
    "tgt_latency": 11,
    "src_size": 92,
    "tgt_size": 60,
    "src_inst": 13,
    "tgt_inst": 7
  },
  "13": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @callme()\n\ndefine void @c_function() {\n#0:\n  %#1 = call i32 @callme()\n  ret void\n}\n=>\ndeclare i32 @callme()\n\ndefine void @c_function() {\n#0:\n  %#1 = call i32 @callme()\n  ret void\n}\nTransformation seems to be correct! (syntactically equal)\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 2,
    "tgt_latency": 2,
    "src_size": 84,
    "tgt_size": 84,
    "src_inst": 2,
    "tgt_inst": 2
  },
  "14": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine void @fn_test4() {\n#0:\n  %#1 = alloca i64 4, align 4\n  store i32 0, ptr %#1, align 4\n  %#2 = load i32, ptr %#1, align 4\n  %#3 = add nsw i32 %#2, 1\n  store i32 %#3, ptr %#1, align 4\n  ret void\n}\n=>\ndefine void @fn_test4() {\n#0:\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 8,
    "tgt_latency": 1,
    "src_size": 76,
    "tgt_size": 44,
    "src_inst": 6,
    "tgt_inst": 1
  },
  "15": {
    "status": "correct",
    "alive_summary": "----------------------------------------\n@d = global 16 bytes, align 8\n\ndefine void @fn8_g(i32 noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#2, align 4\n  %__constexpr_0 = gep inbounds ptr @d, 16 x i32 0, 1 x i64 8\n  %#3 = load i32, ptr %__constexpr_0, align 8\n  %#4 = lshr i32 %#3, 16\n  %#5 = and i32 %#4, 255\n  %#6 = xor i32 %#5, 37\n  %__constexpr_1 = gep inbounds ptr @d, 16 x i32 0, 1 x i64 8\n  %#7 = load i32, ptr %__constexpr_1, align 8\n  %#8 = and i32 %#6, 255\n  %#9 = shl i32 %#8, 16\n  %#10 = and i32 %#7, 4278255615\n  %#11 = or i32 %#10, %#9\n  %__constexpr_2 = gep inbounds ptr @d, 16 x i32 0, 1 x i64 8\n  store i32 %#11, ptr %__constexpr_2, align 8\n  ret void\n}\n=>\n@d = global 16 bytes, align 8\n\ndefine void @fn8_g(i32 noundef %#0) {\n#1:\n  %__constexpr_0 = gep inbounds ptr @d, 16 x i64 0, 1 x i64 8\n  %#2 = load i32, ptr %__constexpr_0, align 8\n  %#3 = lshr i32 %#2, 16\n  %#4 = and i32 %#3, 255\n  %#5 = xor i32 %#4, 37\n  %#6 = and i32 %#5, 255\n  %#7 = shl i32 %#6, 16\n  %#8 = and i32 %#2, 4278255615\n  %#9 = or i32 %#8, %#7\n  %__constexpr_1 = gep inbounds ptr @d, 16 x i64 0, 1 x i64 8\n  store i32 %#9, ptr %__constexpr_1, align 8\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 18,
    "tgt_latency": 13,
    "src_size": 112,
    "tgt_size": 88,
    "src_inst": 13,
    "tgt_inst": 10
  },
  "16": {
    "status": "syntactic error",
    "alive_summary": "Modules have different target triples",
    "src_latency": 23,
    "tgt_latency": 23,
    "src_size": 104,
    "tgt_size": 104,
    "src_inst": 16,
    "tgt_inst": 16
  },
  "17": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\ndefine i64 @f4(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  %#5 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#6 = load i32, ptr %#3, align 4\n  %#7 = load i32, ptr %#4, align 4\n  %#8 = uadd_overflow i32 %#6, %#7\n  %#9 = extractvalue {i32, i1, i24} %#8, 1\n  %#10 = extractvalue {i32, i1, i24} %#8, 0\n  store i32 %#10, ptr %#3, align 4\n  %#11 = zext i1 %#9 to i32\n  store i32 %#11, ptr %#5, align 4\n  %#12 = load i32, ptr %#3, align 4\n  %#13 = load i32, ptr %#5, align 4\n  %#14 = sub i32 %#12, %#13\n  %#15 = zext i32 %#14 to i64\n  ret i64 %#15\n}\n=>\ndefine i64 @f4(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = uadd_overflow i32 noundef %#0, noundef %#1\n  %#5 = extractvalue {i32, i1, i24} %#3, 0\n  %#7 = sub i32 noundef %#0, %#5\n  %#8 = zext i32 %#7 to i64\n  ret i64 %#8\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\ni32 noundef %#0 = #x00000000 (0)\ni32 noundef %#1 = #x00000008 (8)\n\nSource:\nptr %#3 = pointer(local, block_id=0, offset=0) / Address=#x108\nptr %#4 = pointer(local, block_id=1, offset=0) / Address=#x100\nptr %#5 = pointer(local, block_id=2, offset=0) / Address=#x120\ni32 %#6 = #x00000000 (0)\ni32 %#7 = #x00000008 (8)\n{i32, i1, i24} %#8 = { #x00000008 (8), #x0 (0), poison }\ni1 %#9 = #x0 (0)\ni32 %#10 = #x00000008 (8)\ni32 %#11 = #x00000000 (0)\ni32 %#12 = #x00000008 (8)\ni32 %#13 = #x00000000 (0)\ni32 %#14 = #x00000008 (8)\ni64 %#15 = #x0000000000000008 (8)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\talive: true\n\nLOCAL BLOCKS:\nBlock 4 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 264\nBlock 5 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 256\nBlock 6 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 288\n\nTarget:\n{i32, i1, i24} %#3 = { #x00000008 (8), #x0 (0), poison }\ni32 %#5 = #x00000008 (8)\ni32 %#7 = #xfffffff8 (4294967288, -8)\ni64 %#8 = #x00000000fffffff8 (4294967288)\nSource value: #x0000000000000008 (8)\nTarget value: #x00000000fffffff8 (4294967288)\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 24,
    "tgt_latency": 24,
    "src_size": 112,
    "tgt_size": 112,
    "src_inst": 18,
    "tgt_inst": 18
  },
  "18": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpyribe33w.ll'\n/tmp/tmpyribe33w.ll:1:6: error: expected 'type' after '='\n%1 = alloca %struct.eight, align 8\n     ^",
    "src_latency": 10,
    "tgt_latency": 10,
    "src_size": 80,
    "tgt_size": 80,
    "src_inst": 10,
    "tgt_inst": 10
  },
  "19": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\ndeclare i32 @g(...)\n\n@g = constant ? bytes, exec, align 8\n\ndefine i32 @f(i32 noundef %#0) {\n#1:\n  %#8 = alloca i64 4, align 4\n  %#9 = alloca i64 4, align 4\n  %#10 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#9, align 4\n  br i1 0, label %#5, label %#2\n\n#2:\n  %#11 = load i32, ptr %#9, align 4\n  %#12 = icmp ne i32 %#11, 0\n  br i1 %#12, label %#3, label %#4\n\n#3:\n  br label %#6\n\n#4:\n  store i32 5, ptr %#8, align 4\n  br label %#7\n\n#5:\n  %#13 = call i32 @g()\n  br label %#6\n\n#6:\n  store i32 3, ptr %#10, align 4\n  %#14 = load i32, ptr %#10, align 4\n  store i32 %#14, ptr %#8, align 4\n  br label %#7\n\n#7:\n  %#15 = load i32, ptr %#8, align 4\n  ret i32 %#15\n}\n=>\ndeclare i32 @g(...)\n\n@g = constant ? bytes, exec, align 8\n\ndefine i32 @f(i32 noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  %#3 = call i32 @g()\n  ret i32 3\n}\nTransformation doesn't verify!\n\nERROR: Source is more defined than target\n\nExample:\ni32 noundef %#0 = #x00000003 (3)\n\nSource:\nptr %#8 = pointer(local, block_id=0, offset=0) / Address=#x100\nptr %#9 = pointer(local, block_id=1, offset=0) / Address=#x108\nptr %#10 = pointer(local, block_id=2, offset=0) / Address=#x104\n  >> Jump to %#2\ni32 %#11 = #x00000003 (3)\ni1 %#12 = #x1 (1)\n  >> Jump to %#3\n  >> Jump to %#6\ni32 %#14 = #x00000003 (3)\n  >> Jump to %#7\ni32 %#15 = #x00000003 (3)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 0\talign: 4\talloc type: 0\talive: false\taddress: 0\nBlock 1 >\tsize: 7\talign: 8\talloc type: 0\talive: true\taddress: 8\tconst\nBlock 2 >\tsize: 0\talign: 1\talloc type: 0\talive: true\taddress: 6\nBlock 3 >\tsize: 0\talign: 1\talloc type: 0\talive: true\taddress: 7\n\nLOCAL BLOCKS:\nBlock 4 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 256\nBlock 5 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 264\nBlock 6 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 260\n\nTarget:\nptr %#2 = pointer(local, block_id=0, offset=0) / Address=#x100\nFunction  triggered UB\n\nTARGET MEMORY STATE\n===================\nLOCAL BLOCKS:\nBlock 4 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 256\n\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 25,
    "tgt_latency": 25,
    "src_size": 164,
    "tgt_size": 164,
    "src_inst": 19,
    "tgt_inst": 19
  },
  "20": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine void @pr6013_6035_test(ptr noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  %#3 = alloca i64 4, align 4\n  store ptr noundef %#0, ptr %#2, align 8\n  %#4 = load ptr, ptr %#2, align 8\n  %#5 = ptrtoint ptr %#4 to i64\n  %#6 = trunc i64 %#5 to i32\n  store i32 %#6, ptr %#3, align 4\n  %#7 = load i32, ptr %#3, align 4\n  ret void\n}\n=>\ndefine void @pr6013_6035_test(ptr noundef %#0) {\n#1:\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 11,
    "tgt_latency": 1,
    "src_size": 72,
    "tgt_size": 44,
    "src_inst": 9,
    "tgt_inst": 3
  },
  "21": {
    "status": "syntactic error",
    "alive_summary": "Modules have different target triples",
    "src_latency": 10,
    "tgt_latency": 10,
    "src_size": 96,
    "tgt_size": 96,
    "src_inst": 9,
    "tgt_inst": 9
  },
  "22": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare void @bar()\n\ndefine i8 @t175_3mul(i8 noundef %#0) {\n#1:\n  %#4 = alloca i64 1, align 1\n  %#5 = alloca i64 1, align 1\n  store i8 noundef %#0, ptr %#4, align 1\n  %#6 = load i8, ptr %#4, align 1\n  %#7 = umul_overflow i8 10, %#6\n  %#8 = extractvalue {i8, i1} %#7, 1\n  %#9 = extractvalue {i8, i1} %#7, 0\n  store i8 %#9, ptr %#5, align 1\n  br i1 %#8, label %#2, label %#3\n\n#2:\n  call void @bar()\n  br label %#3\n\n#3:\n  %#10 = load i8, ptr %#5, align 1\n  ret i8 %#10\n}\n=>\ndeclare void @bar()\n\ndefine i8 @t175_3mul(i8 noundef %#0) {\n#1:\n  %#4 = umul_overflow i8 10, noundef %#0\n  %#5 = extractvalue {i8, i1} %#4, 1\n  %#6 = extractvalue {i8, i1} %#4, 0\n  br i1 %#5, label %#2, label %#3\n\n#2:\n  call void @bar()\n  br label %#3\n\n#3:\n  ret i8 %#6\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 18,
    "tgt_latency": 8,
    "src_size": 136,
    "tgt_size": 132,
    "src_inst": 13,
    "tgt_inst": 7
  },
  "23": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\ndefine i32 @f1(i32 noundef %#0, i8 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 1, align 1\n  store i32 noundef %#0, ptr %#3, align 4\n  store i8 noundef %#1, ptr %#4, align 1\n  %#5 = load i8, ptr %#4, align 1\n  %#6 = zext i8 %#5 to i32\n  %#7 = srem i32 %#6, 32\n  %#8 = trunc i32 %#7 to i8\n  store i8 %#8, ptr %#4, align 1\n  %#9 = load i32, ptr %#3, align 4\n  %#10 = load i8, ptr %#4, align 1\n  %#11 = zext i8 %#10 to i32\n  %#12 = shl i32 %#9, %#11\n  %#13 = load i32, ptr %#3, align 4\n  %#14 = load i8, ptr %#4, align 1\n  %#15 = zext i8 %#14 to i32\n  %#16 = sub nsw i32 32, %#15\n  %#17 = lshr i32 %#13, %#16\n  %#18 = or i32 %#12, %#17\n  ret i32 %#18\n}\n=>\ndefine i32 @f1(i32 noundef %#0, i8 noundef %#1) {\n#2:\n  %#3 = zext i8 noundef %#1 to i32\n  %#4 = srem i32 %#3, 32\n  %#5 = trunc i32 %#4 to i8\n  %#6 = zext i8 %#5 to i32\n  %#7 = shl i32 noundef %#0, %#6\n  %#8 = zext i8 noundef %#1 to i32\n  %#9 = sub nsw i32 32, %#8\n  %#10 = lshr i32 %#7, %#9\n  %#11 = or i32 %#7, %#10\n  ret i32 %#11\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\ni32 noundef %#0 = #x00000003 (3)\ni8 noundef %#1 = #xc2 (194, -62)\n\nSource:\nptr %#3 = pointer(local, block_id=0, offset=0) / Address=#x130\nptr %#4 = pointer(local, block_id=1, offset=0) / Address=#x100\ni8 %#5 = #xc2 (194, -62)\ni32 %#6 = #x000000c2 (194)\ni32 %#7 = #x00000002 (2)\ni8 %#8 = #x02 (2)\ni32 %#9 = #x00000003 (3)\ni8 %#10 = #x02 (2)\ni32 %#11 = #x00000002 (2)\ni32 %#12 = #x0000000c (12)\ni32 %#13 = #x00000003 (3)\ni8 %#14 = #x02 (2)\ni32 %#15 = #x00000002 (2)\ni32 %#16 = #x0000001e (30)\ni32 %#17 = #x00000000 (0)\ni32 %#18 = #x0000000c (12)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\talive: true\n\nLOCAL BLOCKS:\nBlock 2 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 304\nBlock 3 >\tsize: 1\talign: 1\talloc type: 1\talive: true\taddress: 256\n\nTarget:\ni32 %#3 = #x000000c2 (194)\ni32 %#4 = #x00000002 (2)\ni8 %#5 = #x02 (2)\ni32 %#6 = #x00000002 (2)\ni32 %#7 = #x0000000c (12)\ni32 %#8 = #x000000c2 (194)\ni32 %#9 = #xffffff5e (4294967134, -162)\ni32 %#10 = poison\ni32 %#11 = poison\nSource value: #x0000000c (12)\nTarget value: poison\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 32,
    "tgt_latency": 32,
    "src_size": 124,
    "tgt_size": 124,
    "src_inst": 20,
    "tgt_inst": 20
  },
  "24": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpg5haytb8.ll'\n/tmp/tmpg5haytb8.ll:13:13: error: use of undefined value '@bar'\n  call void @bar()\n            ^",
    "src_latency": 19,
    "tgt_latency": 19,
    "src_size": 160,
    "tgt_size": 160,
    "src_inst": 18,
    "tgt_inst": 18
  },
  "25": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @foo(...)\ndeclare i32 @bar(...)\ndeclare i32 @baz(...)\n\n@foo = constant ? bytes, exec, align 8\n@bar = constant ? bytes, exec, align 8\n@baz = constant ? bytes, exec, align 8\n\ndefine i32 @main(i32 noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  %#5 = alloca i64 4, align 4\n  %#6 = alloca i64 4, align 4\n  store i32 0, ptr %#2, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  %#7 = load i32, ptr %#3, align 4\n  %#8 = call i32 @foo(...noundef i32 %#7)\n  store i32 %#8, ptr %#4, align 4\n  %#9 = load i32, ptr %#3, align 4\n  %#10 = call i32 @bar(...noundef i32 %#9)\n  store i32 %#10, ptr %#5, align 4\n  %#11 = load i32, ptr %#3, align 4\n  %#12 = call i32 @baz(...noundef i32 %#11)\n  store i32 %#12, ptr %#6, align 4\n  %#13 = load i32, ptr %#4, align 4\n  %#14 = load i32, ptr %#6, align 4\n  %#15 = add nsw i32 %#13, %#14\n  ret i32 %#15\n}\n=>\ndeclare i32 @foo(...)\ndeclare i32 @bar(...)\ndeclare i32 @baz(...)\n\n@foo = constant ? bytes, exec, align 8\n@bar = constant ? bytes, exec, align 8\n@baz = constant ? bytes, exec, align 8\n\ndefine i32 @main(i32 noundef %#0) {\n#1:\n  %#2 = call i32 @foo(...noundef i32 noundef %#0)\n  %#3 = call i32 @bar(...noundef i32 noundef %#0)\n  %#4 = call i32 @baz(...noundef i32 noundef %#0)\n  %#5 = add nsw i32 %#2, %#4\n  ret i32 %#5\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 33,
    "tgt_latency": 8,
    "src_size": 144,
    "tgt_size": 132,
    "src_inst": 20,
    "tgt_inst": 5
  },
  "26": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i32 @my_is_prime(i32 noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#2, align 4\n  ret i32 0\n}\n=>\ndefine i32 @my_is_prime(i32 noundef %#0) {\n#1:\n  ret i32 0\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 2,
    "tgt_latency": 1,
    "src_size": 68,
    "tgt_size": 48,
    "src_inst": 3,
    "tgt_inst": 1
  },
  "27": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine float @h(float noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  store float noundef %#0, ptr %#2, align 4\n  %#3 = load float, ptr %#2, align 4\n  %#4 = load float, ptr %#2, align 4\n  %#5 = fcmp olt float %#4, 0.000000\n  %#7 = select i1 %#5, float -1.000000, float 1.000000\n  %#8 = fmul float %#3, %#7\n  ret float %#8\n}\n=>\ndefine float @h(float noundef %#0) {\n#1:\n  %#2 = fcmp olt float noundef %#0, 0.000000\n  %#4 = select i1 %#2, float -1.000000, float 1.000000\n  %#5 = fmul float noundef %#0, %#4\n  ret float %#5\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 15,
    "tgt_latency": 6,
    "src_size": 92,
    "tgt_size": 64,
    "src_inst": 9,
    "tgt_inst": 5
  },
  "28": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i8 @_ZN25custom_lessthan_constantsIaE8do_shiftEa(i8 noundef %#0) noundef {\n#1:\n  %#2 = alloca i64 1, align 1\n  store i8 noundef %#0, ptr %#2, align 1\n  ret i8 0\n}\n=>\ndefine i8 @_ZN25custom_lessthan_constantsIaE8do_shiftEa(i8 noundef %#0) noundef {\n#1:\n  ret i8 0\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 2,
    "tgt_latency": 1,
    "src_size": 68,
    "tgt_size": 48,
    "src_inst": 3,
    "tgt_inst": 1
  },
  "29": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i32 @sumar(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#5 = load i32, ptr %#3, align 4\n  %#6 = load i32, ptr %#4, align 4\n  %#7 = add nsw i32 %#5, %#6\n  ret i32 %#7\n}\n=>\ndefine i32 @sumar(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = add nsw i32 noundef %#0, noundef %#1\n  ret i32 %#3\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 12,
    "tgt_latency": 2,
    "src_size": 80,
    "tgt_size": 48,
    "src_inst": 8,
    "tgt_inst": 2
  },
  "30": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare void @mbedtls_zeroize(noundef ptr, noundef i64)\ndeclare void @free(noundef ptr)\n\ndefine void @rsa_alt_free_wrap(ptr noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#2, align 8\n  %#3 = load ptr, ptr %#2, align 8\n  call void @mbedtls_zeroize(noundef ptr %#3, noundef i64 32)\n  %#4 = load ptr, ptr %#2, align 8\n  call void @free(noundef allocptr ptr %#4) nothrow willreturn alloc-family(malloc) allockind(free) memory(inaccessiblemem: readwrite)\n  ret void\n}\n=>\ndeclare void @mbedtls_zeroize(noundef ptr, noundef i64)\ndeclare void @free(noundef ptr)\n\ndefine void @rsa_alt_free_wrap(ptr noundef %#0) {\n#1:\n  call void @mbedtls_zeroize(noundef ptr noundef %#0, noundef i64 32)\n  call void @free(noundef allocptr ptr noundef %#0) nothrow willreturn alloc-family(malloc) allockind(free) memory(inaccessiblemem: readwrite)\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 15,
    "tgt_latency": 6,
    "src_size": 116,
    "tgt_size": 112,
    "src_inst": 7,
    "tgt_inst": 3
  },
  "31": {
    "status": "correct",
    "alive_summary": "----------------------------------------\n@array = global 16 bytes, align 4\n\ndefine i32 @main() {\n#0:\n  %#1 = alloca i64 4, align 4\n  store i32 0, ptr %#1, align 4\n  %#2 = load i32, ptr @array, align 4\n  %#3 = sub nsw i32 %#2, 1\n  ret i32 %#3\n}\n=>\n@array = global 16 bytes, align 4\n\ndefine i32 @main() {\n#0:\n  %#1 = load i32, ptr @array, align 4\n  %#2 = sub nsw i32 %#1, 1\n  ret i32 %#2\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 7,
    "tgt_latency": 6,
    "src_size": 76,
    "tgt_size": 56,
    "src_inst": 5,
    "tgt_inst": 3
  }
}