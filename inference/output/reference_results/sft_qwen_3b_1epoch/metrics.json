{
  "0": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @faki(...)\n\n@faki = constant ? bytes, exec, align 8\n\ndefine i64 @bikoeff(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#5 = load i32, ptr %#4, align 4\n  %#6 = call i32 @faki(...noundef i32 %#5)\n  %#7 = load i32, ptr %#3, align 4\n  %#8 = call i32 @faki(...noundef i32 %#7)\n  %#9 = sdiv i32 %#6, %#8\n  %#10 = load i32, ptr %#4, align 4\n  %#11 = load i32, ptr %#3, align 4\n  %#12 = sub nsw i32 %#10, %#11\n  %#13 = call i32 @faki(...noundef i32 %#12)\n  %#14 = mul nsw i32 %#9, %#13\n  %#15 = sext i32 %#14 to i64\n  ret i64 %#15\n}\n=>\ndeclare i32 @faki(...)\n\n@faki = constant ? bytes, exec, align 8\n\ndefine i64 @bikoeff(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = call i32 @faki(...noundef i32 noundef %#1)\n  %#4 = call i32 @faki(...noundef i32 noundef %#0)\n  %#5 = sdiv i32 %#3, %#4\n  %#6 = sub nsw i32 noundef %#1, noundef %#0\n  %#7 = call i32 @faki(...noundef i32 %#6)\n  %#8 = mul nsw i32 %#5, %#7\n  %#9 = sext i32 %#8 to i64\n  ret i64 %#9\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 32,
    "tgt_latency": 14,
    "src_size": 164,
    "tgt_size": 168,
    "src_inst": 16,
    "tgt_inst": 8
  },
  "1": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmp9w8a5ruc.ll'\n/tmp/tmp9w8a5ruc.ll:35:1: error: expected top-level entity\n->\n^",
    "src_latency": 9,
    "tgt_latency": 9,
    "src_size": 108,
    "tgt_size": 108,
    "src_inst": 8,
    "tgt_inst": 8
  },
  "2": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpajx8_dwp.ll'\n/tmp/tmpajx8_dwp.ll:28:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 10,
    "tgt_latency": 10,
    "src_size": 136,
    "tgt_size": 136,
    "src_inst": 5,
    "tgt_inst": 5
  },
  "3": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpdxqu1raz.ll'\n/tmp/tmpdxqu1raz.ll:31:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 20,
    "tgt_latency": 20,
    "src_size": 100,
    "tgt_size": 100,
    "src_inst": 13,
    "tgt_inst": 13
  },
  "4": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmps_ww0yii.ll'\n/tmp/tmps_ww0yii.ll:33:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 18,
    "tgt_latency": 18,
    "src_size": 116,
    "tgt_size": 116,
    "src_inst": 8,
    "tgt_inst": 8
  },
  "5": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare ptr @my_alloc2(noundef i32, noundef i32)\n\ndefine i32 @test6(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  %#5 = alloca i64 4, align 4\n  %#6 = alloca i64 8, align 8\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#7 = load i32, ptr %#4, align 4\n  %#8 = load i32, ptr %#3, align 4\n  %#9 = call ptr @my_alloc2(noundef i32 %#7, noundef i32 %#8)\n  %#10 = zext i32 %#7 to i64\n  assume_align ptr %#9, i64 %#10\n  store ptr %#9, ptr %#6, align 8\n  %#11 = load ptr, ptr %#6, align 8\n  %#12 = ptrtoint ptr %#11 to i64\n  %#13 = and i64 %#12, 15\n  %#14 = trunc i64 %#13 to i32\n  ret i32 %#14\n}\n=>\ndeclare ptr @my_alloc2(noundef i32, noundef i32)\n\ndefine i32 @test6(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = call ptr @my_alloc2(noundef i32 noundef %#1, noundef i32 noundef %#0)\n  %#4 = ptrtoint ptr %#3 to i64\n  %#5 = and i64 %#4, 15\n  %#6 = trunc i64 %#5 to i32\n  ret i32 %#6\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 20,
    "tgt_latency": 5,
    "src_size": 124,
    "tgt_size": 112,
    "src_inst": 17,
    "tgt_inst": 5
  },
  "6": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare ptr @frnn1() nonnull\ndeclare void @foo()\n\ndefine void @frnn_local_local() {\n#0:\n  %#3 = call ptr @frnn1() nonnull\n  %#4 = icmp ne ptr %#3, null\n  br i1 %#4, label %#2, label %#1\n\n#1:\n  call void @foo()\n  br label %#2\n\n#2:\n  ret void\n}\n=>\ndeclare ptr @frnn1() nonnull\ndeclare void @foo()\n\ndefine void @frnn_local_local() {\n#0:\n  %#3 = call ptr @frnn1() nonnull\n  %.not = icmp eq ptr %#3, null\n  br i1 %.not, label %#1, label %#2\n\n#1:\n  call void @foo()\n  br label %#2\n\n#2:\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 6,
    "tgt_latency": 6,
    "src_size": 100,
    "tgt_size": 100,
    "src_inst": 6,
    "tgt_inst": 6
  },
  "7": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare double @pow(noundef double, noundef double)\n\ndefine double @test3b(double noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store double noundef %#0, ptr %#2, align 8\n  %#3 = load double, ptr %#2, align 8\n  %#4 = call double @pow(noundef double %#3, noundef double -1.666667)\n  ret double %#4\n}\n=>\ndeclare double @pow(noundef double, noundef double)\n\ndefine double @test3b(double noundef %#0) {\n#1:\n  %#2 = call double @pow(noundef double noundef %#0, noundef double -1.666667)\n  ret double %#2\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 7,
    "tgt_latency": 2,
    "src_size": 116,
    "tgt_size": 100,
    "src_inst": 5,
    "tgt_inst": 2
  },
  "8": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare ptr @memchr(noundef ptr, noundef i32, noundef i64)\n\n@.str = constant 2 bytes, align 1\n\ndefine i32 @f(i8 noundef %#0) {\n#1:\n  %#2 = alloca i64 1, align 1\n  store i8 noundef %#0, ptr %#2, align 1\n  %#3 = load i8, ptr %#2, align 1\n  %#4 = zext i8 %#3 to i32\n  %#5 = call ptr @memchr(noundef ptr @.str, noundef i32 %#4, noundef i64 1) nofree noundef nothrow willreturn memory(argmem: read)\n  %#6 = icmp eq ptr %#5, null\n  %#7 = zext i1 %#6 to i32\n  ret i32 %#7\n}\n=>\ndeclare ptr @memchr(noundef ptr, noundef i32, noundef i64)\n\n@.str = constant 2 bytes, align 1\n\ndefine i32 @f(i8 noundef %#0) {\n#1:\n  %#2 = zext i8 noundef %#0 to i32\n  %#3 = call ptr @memchr(nonnull dereferenceable(1) noundef ptr @.str, noundef i32 %#2, noundef i64 1) nofree noundef nothrow willreturn memory(argmem: read)\n  %#4 = icmp eq ptr %#3, null\n  %#5 = zext i1 %#4 to i32\n  ret i32 %#5\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 12,
    "tgt_latency": 8,
    "src_size": 124,
    "tgt_size": 112,
    "src_inst": 8,
    "tgt_inst": 5
  },
  "9": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpgc0xbhlp.ll'\n/tmp/tmpgc0xbhlp.ll:31:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 12,
    "tgt_latency": 12,
    "src_size": 84,
    "tgt_size": 84,
    "src_inst": 9,
    "tgt_inst": 9
  },
  "10": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\ndefine i16 @test_u16_8_255(i16 noundef %#0) {\n#1:\n  %#2 = alloca i64 2, align 2\n  store i16 noundef %#0, ptr %#2, align 2\n  %#3 = load i16, ptr %#2, align 2\n  %#4 = bswap i16 %#3\n  %#5 = zext i16 %#4 to i32\n  %#6 = ashr i32 %#5, 8\n  %#7 = and i32 %#6, 255\n  %#8 = trunc i32 %#7 to i16\n  ret i16 %#8\n}\n=>\ndefine i16 @test_u16_8_255(i16 noundef %#0) {\n#1:\n  %#2 = lshr i16 noundef %#0, 8\n  %#3 = and i16 %#2, 255\n  ret i16 %#3\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\ni16 noundef %#0 = #x0002 (2)\n\nSource:\nptr %#2 = pointer(local, block_id=0, offset=0) / Address=#x100\ni16 %#3 = #x0002 (2)\ni16 %#4 = #x0200 (512)\ni32 %#5 = #x00000200 (512)\ni32 %#6 = #x00000002 (2)\ni32 %#7 = #x00000002 (2)\ni16 %#8 = #x0002 (2)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\talive: true\n\nLOCAL BLOCKS:\nBlock 2 >\tsize: 2\talign: 2\talloc type: 1\talive: true\taddress: 256\n\nTarget:\ni16 %#2 = #x0000 (0)\ni16 %#3 = #x0000 (0)\nSource value: #x0002 (2)\nTarget value: #x0000 (0)\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 10,
    "tgt_latency": 10,
    "src_size": 84,
    "tgt_size": 84,
    "src_inst": 9,
    "tgt_inst": 9
  },
  "11": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @foo()\ndeclare void @exit(noundef i32) noreturn\ndeclare void @abort() noreturn\n\ndefine i32 @main() {\n#0:\n  %#3 = alloca i64 4, align 4\n  store i32 0, ptr %#3, align 4\n  %#4 = call i32 @foo()\n  %#5 = icmp ne i32 %#4, 4044\n  br i1 %#5, label %#2, label %#1\n\n#1:\n  call void @exit(noundef i32 0) noreturn\n  assume i1 0\n\n#2:\n  call void @abort() noreturn\n  assume i1 0\n}\n=>\ndeclare i32 @foo()\ndeclare void @abort() noreturn\ndeclare void @exit(noundef i32) noreturn\n\ndefine i32 @main() {\n#0:\n  %#3 = call i32 @foo()\n  %.not = icmp eq i32 %#3, 4044\n  br i1 %.not, label %#2, label %#1\n\n#1:\n  call void @abort() noreturn\n  assume i1 0\n\n#2:\n  call void @exit(noundef i32 0) noreturn\n  assume i1 0\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 9,
    "tgt_latency": 8,
    "src_size": 92,
    "tgt_size": 84,
    "src_inst": 9,
    "tgt_inst": 7
  },
  "12": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine void @orit(ptr noundef %#0, ptr noundef %#1) {\n#2:\n  %#3 = alloca i64 8, align 8\n  %#4 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#3, align 8\n  store ptr noundef %#1, ptr %#4, align 8\n  %#5 = load ptr, ptr %#3, align 8\n  %#6 = gep inbounds ptr %#5, 8 x i32 0, 1 x i64 0\n  %#7 = load i64, ptr %#6, align 8\n  %#8 = load ptr, ptr %#4, align 8\n  %#9 = gep inbounds ptr %#8, 8 x i32 0, 1 x i64 0\n  %#10 = load i64, ptr %#9, align 8\n  %#11 = or i64 %#10, %#7\n  store i64 %#11, ptr %#9, align 8\n  ret void\n}\n=>\ndefine void @orit(ptr noundef %#0, ptr noundef %#1) {\n#2:\n  %#3 = gep inbounds ptr noundef %#0, 8 x i64 0, 1 x i64 0\n  %#4 = load i64, ptr %#3, align 8\n  %#5 = gep inbounds ptr noundef %#1, 8 x i64 0, 1 x i64 0\n  %#6 = load i64, ptr %#5, align 8\n  %#7 = or i64 %#6, %#4\n  store i64 %#7, ptr %#5, align 8\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 21,
    "tgt_latency": 11,
    "src_size": 92,
    "tgt_size": 60,
    "src_inst": 13,
    "tgt_inst": 7
  },
  "13": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpmjqiqy1i.ll'\n/tmp/tmpmjqiqy1i.ll:32:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 2,
    "tgt_latency": 2,
    "src_size": 84,
    "tgt_size": 84,
    "src_inst": 2,
    "tgt_inst": 2
  },
  "14": {
    "status": "syntactic error",
    "alive_summary": "Modules have different target triples",
    "src_latency": 8,
    "tgt_latency": 8,
    "src_size": 76,
    "tgt_size": 76,
    "src_inst": 6,
    "tgt_inst": 6
  },
  "15": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\n@d = global 16 bytes, align 8\n\ndefine void @fn8_g(i32 noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#2, align 4\n  %__constexpr_0 = gep inbounds ptr @d, 16 x i32 0, 1 x i64 8\n  %#3 = load i32, ptr %__constexpr_0, align 8\n  %#4 = lshr i32 %#3, 16\n  %#5 = and i32 %#4, 255\n  %#6 = xor i32 %#5, 37\n  %__constexpr_1 = gep inbounds ptr @d, 16 x i32 0, 1 x i64 8\n  %#7 = load i32, ptr %__constexpr_1, align 8\n  %#8 = and i32 %#6, 255\n  %#9 = shl i32 %#8, 16\n  %#10 = and i32 %#7, 4278255615\n  %#11 = or i32 %#10, %#9\n  %__constexpr_2 = gep inbounds ptr @d, 16 x i32 0, 1 x i64 8\n  store i32 %#11, ptr %__constexpr_2, align 8\n  ret void\n}\n=>\n@d = global 16 bytes, align 8\n\ndefine void @fn8_g(i32 noundef %#0) {\n#1:\n  %__constexpr_0 = gep inbounds ptr @d, 16 x i64 0, 1 x i64 8\n  %#2 = load i32, ptr %__constexpr_0, align 8\n  %#3 = xor i32 %#2, 37\n  %#4 = and i32 %#3, 16711680\n  %#5 = and i32 %#2, 4278255615\n  %#6 = or i32 %#5, %#4\n  %__constexpr_1 = gep inbounds ptr @d, 16 x i64 0, 1 x i64 8\n  store i32 %#6, ptr %__constexpr_1, align 8\n  ret void\n}\nTransformation doesn't verify!\n\nERROR: Mismatch in memory\n\nExample:\ni32 noundef %#0 = #x00000003 (3)\n\nSource:\nptr %#2 = pointer(local, block_id=0, offset=0) / Address=#x100\nptr %__constexpr_0 = pointer(non-local, block_id=0, offset=8) / Address=#x028\ni32 %#3 = #x00000000 (0)\ni32 %#4 = #x00000000 (0)\ni32 %#5 = #x00000000 (0)\ni32 %#6 = #x00000025 (37)\nptr %__constexpr_1 = pointer(non-local, block_id=0, offset=8) / Address=#x028\ni32 %#7 = #x00000000 (0)\ni32 %#8 = #x00000025 (37)\ni32 %#9 = #x00250000 (2424832)\ni32 %#10 = #x00000000 (0)\ni32 %#11 = #x00250000 (2424832)\nptr %__constexpr_2 = pointer(non-local, block_id=0, offset=8) / Address=#x028\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 16\talign: 8\talloc type: 0\talive: true\taddress: 32\nContents:\n*: #x00000000\n\n\nLOCAL BLOCKS:\nBlock 2 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 256\n\nTarget:\nptr %__constexpr_0 = pointer(non-local, block_id=0, offset=8) / Address=#x028\ni32 %#2 = #x00000000 (0)\ni32 %#3 = #x00000025 (37)\ni32 %#4 = #x00000000 (0)\ni32 %#5 = #x00000000 (0)\ni32 %#6 = #x00000000 (0)\nptr %__constexpr_1 = pointer(non-local, block_id=0, offset=8) / Address=#x028\n\nMismatch in pointer(non-local, block_id=0, offset=8)\nSource value: #x00250000\nTarget value: #x00000000\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 18,
    "tgt_latency": 18,
    "src_size": 112,
    "tgt_size": 112,
    "src_inst": 13,
    "tgt_inst": 13
  },
  "16": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i16 @f69(i16 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 2, align 2\n  %#4 = alloca i64 4, align 4\n  store i16 noundef %#0, ptr %#3, align 2\n  store i32 noundef %#1, ptr %#4, align 4\n  %#5 = load i16, ptr %#3, align 2\n  %#6 = zext i16 %#5 to i32\n  %#7 = load i32, ptr %#4, align 4\n  %#8 = shl i32 %#6, %#7\n  %#9 = load i16, ptr %#3, align 2\n  %#10 = zext i16 %#9 to i32\n  %#11 = load i32, ptr %#4, align 4\n  %#12 = sub nsw i32 16, %#11\n  %#13 = ashr i32 %#10, %#12\n  %#14 = add nsw i32 %#8, %#13\n  %#15 = trunc i32 %#14 to i16\n  ret i16 %#15\n}\n=>\ndefine i16 @f69(i16 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = zext i16 noundef %#0 to i32\n  %#4 = shl i32 %#3, noundef %#1\n  %#5 = zext i16 noundef %#0 to i32\n  %#6 = sub nsw i32 16, noundef %#1\n  %#7 = lshr i32 %#5, %#6\n  %#8 = add nsw i32 %#4, %#7\n  %#9 = trunc i32 %#8 to i16\n  ret i16 %#9\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 23,
    "tgt_latency": 7,
    "src_size": 104,
    "tgt_size": 72,
    "src_inst": 16,
    "tgt_inst": 8
  },
  "17": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i64 @f4(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  %#5 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  store i32 noundef %#1, ptr %#4, align 4\n  %#6 = load i32, ptr %#3, align 4\n  %#7 = load i32, ptr %#4, align 4\n  %#8 = uadd_overflow i32 %#6, %#7\n  %#9 = extractvalue {i32, i1, i24} %#8, 1\n  %#10 = extractvalue {i32, i1, i24} %#8, 0\n  store i32 %#10, ptr %#3, align 4\n  %#11 = zext i1 %#9 to i32\n  store i32 %#11, ptr %#5, align 4\n  %#12 = load i32, ptr %#3, align 4\n  %#13 = load i32, ptr %#5, align 4\n  %#14 = sub i32 %#12, %#13\n  %#15 = zext i32 %#14 to i64\n  ret i64 %#15\n}\n=>\ndefine i64 @f4(i32 noundef %#0, i32 noundef %#1) {\n#2:\n  %#3 = uadd_overflow i32 noundef %#0, noundef %#1\n  %#4 = extractvalue {i32, i1, i24} %#3, 1\n  %#5 = extractvalue {i32, i1, i24} %#3, 0\n  %#6 = zext i1 %#4 to i32\n  %#7 = sub i32 %#5, %#6\n  %#8 = zext i32 %#7 to i64\n  ret i64 %#8\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 24,
    "tgt_latency": 4,
    "src_size": 112,
    "tgt_size": 64,
    "src_inst": 18,
    "tgt_inst": 7
  },
  "18": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndefine i64 @dfn_reight() {\n#0:\n  %#1 = alloca i64 8, align 8\n  %#2 = alloca i64 8, align 8\n  %#3 = gep inbounds ptr %#2, 8 x i32 0, 1 x i64 0\n  store i64 4, ptr %#3, align 8\n  %#4 = bitcast ptr %#1 to ptr\n  %#5 = bitcast ptr %#2 to ptr\n  memcpy ptr %#4 align 8, ptr %#5 align 8, i64 8\n  %#6 = gep inbounds ptr %#1, 8 x i32 0, 1 x i64 0\n  %#7 = load i64, ptr %#6, align 8\n  ret i64 %#7\n}\n=>\ndefine i64 @dfn_reight() {\n#0:\n  ret i64 4\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 10,
    "tgt_latency": 1,
    "src_size": 80,
    "tgt_size": 52,
    "src_inst": 10,
    "tgt_inst": 1
  },
  "19": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\ndeclare i32 @g(...)\n\n@g = constant ? bytes, exec, align 8\n\ndefine i32 @f(i32 noundef %#0) {\n#1:\n  %#8 = alloca i64 4, align 4\n  %#9 = alloca i64 4, align 4\n  %#10 = alloca i64 4, align 4\n  store i32 noundef %#0, ptr %#9, align 4\n  br i1 0, label %#5, label %#2\n\n#2:\n  %#11 = load i32, ptr %#9, align 4\n  %#12 = icmp ne i32 %#11, 0\n  br i1 %#12, label %#3, label %#4\n\n#3:\n  br label %#6\n\n#4:\n  store i32 5, ptr %#8, align 4\n  br label %#7\n\n#5:\n  %#13 = call i32 @g()\n  br label %#6\n\n#6:\n  store i32 3, ptr %#10, align 4\n  %#14 = load i32, ptr %#10, align 4\n  store i32 %#14, ptr %#8, align 4\n  br label %#7\n\n#7:\n  %#15 = load i32, ptr %#8, align 4\n  ret i32 %#15\n}\n=>\ndeclare i32 @g(...)\n\n@g = constant ? bytes, exec, align 8\n\ndefine i32 @f(i32 noundef %#0) {\n#1:\n  %#8 = alloca i64 4, align 4\n  br i1 0, label %#5, label %#2\n\n#2:\n  %#9 = load i32, ptr %#8, align 4\n  %.not = icmp eq i32 %#9, 0\n  br i1 %.not, label %#3, label %#4\n\n#3:\n  store i32 5, ptr %#8, align 4\n  br label %#7\n\n#4:\n  br label %#6\n\n#5:\n  %#10 = call i32 @g()\n  br label %#6\n\n#6:\n  store i32 3, ptr %#8, align 4\n  br label %#7\n\n#7:\n  %#11 = load i32, ptr %#8, align 4\n  ret i32 %#11\n}\nTransformation doesn't verify!\n\nERROR: Source is more defined than target\n\nExample:\ni32 noundef %#0 = #x00000003 (3)\n\nSource:\nptr %#8 = pointer(local, block_id=0, offset=0) / Address=#x108\nptr %#9 = pointer(local, block_id=1, offset=0) / Address=#x100\nptr %#10 = pointer(local, block_id=2, offset=0) / Address=#x104\n  >> Jump to %#2\ni32 %#11 = #x00000003 (3)\ni1 %#12 = #x1 (1)\n  >> Jump to %#3\n  >> Jump to %#6\ni32 %#14 = #x00000003 (3)\n  >> Jump to %#7\ni32 %#15 = #x00000003 (3)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 0\talign: 4\talloc type: 0\talive: false\taddress: 0\nBlock 1 >\tsize: 15\talign: 8\talloc type: 0\talive: true\taddress: 192\tconst\nBlock 2 >\tsize: 0\talign: 4\talloc type: 0\talive: true\taddress: 220\nBlock 3 >\tsize: 0\talign: 1\talloc type: 0\talive: true\taddress: 221\n\nLOCAL BLOCKS:\nBlock 4 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 264\nBlock 5 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 256\nBlock 6 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 260\n\nTarget:\nptr %#8 = null\n  >> Jump to %#2\ni32 %#9 = poison\ni1 %.not = poison\nUB triggered on br\n\nTARGET MEMORY STATE\n===================\nLOCAL BLOCKS:\nBlock 4 >\tsize: 0\talign: 4\talloc type: 0\talive: false\taddress: 0\n\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 25,
    "tgt_latency": 25,
    "src_size": 164,
    "tgt_size": 164,
    "src_inst": 19,
    "tgt_inst": 19
  },
  "20": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmp5jmdmf04.ll'\n/tmp/tmp5jmdmf04.ll:27:1: error: expected top-level entity\nend answer\n^",
    "src_latency": 11,
    "tgt_latency": 11,
    "src_size": 72,
    "tgt_size": 72,
    "src_inst": 9,
    "tgt_inst": 9
  },
  "21": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @test(noundef i32)\ndeclare void @exit(noundef i32) noreturn\ndeclare void @abort() noreturn\n\ndefine i32 @main() {\n#0:\n  %#3 = alloca i64 4, align 4\n  store i32 0, ptr %#3, align 4\n  %#4 = call i32 @test(noundef i32 5)\n  %#5 = icmp ne i32 %#4, 2\n  br i1 %#5, label %#2, label %#1\n\n#1:\n  call void @exit(noundef i32 0) noreturn\n  assume i1 0\n\n#2:\n  call void @abort() noreturn\n  assume i1 0\n}\n=>\ndeclare i32 @test(noundef i32)\ndeclare void @abort() noreturn\ndeclare void @exit(noundef i32) noreturn\n\ndefine i32 @main() {\n#0:\n  %#3 = call i32 @test(noundef i32 5)\n  %.not = icmp eq i32 %#3, 2\n  br i1 %.not, label %#2, label %#1\n\n#1:\n  call void @abort() noreturn\n  assume i1 0\n\n#2:\n  call void @exit(noundef i32 0) noreturn\n  assume i1 0\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 10,
    "tgt_latency": 9,
    "src_size": 96,
    "tgt_size": 88,
    "src_inst": 9,
    "tgt_inst": 7
  },
  "22": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare void @bar()\n\ndefine i8 @t175_3mul(i8 noundef %#0) {\n#1:\n  %#4 = alloca i64 1, align 1\n  %#5 = alloca i64 1, align 1\n  store i8 noundef %#0, ptr %#4, align 1\n  %#6 = load i8, ptr %#4, align 1\n  %#7 = umul_overflow i8 10, %#6\n  %#8 = extractvalue {i8, i1} %#7, 1\n  %#9 = extractvalue {i8, i1} %#7, 0\n  store i8 %#9, ptr %#5, align 1\n  br i1 %#8, label %#2, label %#3\n\n#2:\n  call void @bar()\n  br label %#3\n\n#3:\n  %#10 = load i8, ptr %#5, align 1\n  ret i8 %#10\n}\n=>\ndeclare void @bar()\n\ndefine i8 @t175_3mul(i8 noundef %#0) {\n#1:\n  %#4 = alloca i64 1, align 4\n  %#5 = umul_overflow i8 noundef %#0, 10\n  %#6 = extractvalue {i8, i1} %#5, 1\n  %#7 = extractvalue {i8, i1} %#5, 0\n  store i8 %#7, ptr %#4, align 4\n  br i1 %#6, label %#2, label %#3\n\n#2:\n  call void @bar()\n  br label %#3\n\n#3:\n  %#8 = load i8, ptr %#4, align 4\n  ret i8 %#8\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 18,
    "tgt_latency": 13,
    "src_size": 136,
    "tgt_size": 132,
    "src_inst": 13,
    "tgt_inst": 10
  },
  "23": {
    "status": "semantic error",
    "alive_summary": "----------------------------------------\ndefine i32 @f1(i32 noundef %#0, i8 noundef %#1) {\n#2:\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 1, align 1\n  store i32 noundef %#0, ptr %#3, align 4\n  store i8 noundef %#1, ptr %#4, align 1\n  %#5 = load i8, ptr %#4, align 1\n  %#6 = zext i8 %#5 to i32\n  %#7 = srem i32 %#6, 32\n  %#8 = trunc i32 %#7 to i8\n  store i8 %#8, ptr %#4, align 1\n  %#9 = load i32, ptr %#3, align 4\n  %#10 = load i8, ptr %#4, align 1\n  %#11 = zext i8 %#10 to i32\n  %#12 = shl i32 %#9, %#11\n  %#13 = load i32, ptr %#3, align 4\n  %#14 = load i8, ptr %#4, align 1\n  %#15 = zext i8 %#14 to i32\n  %#16 = sub nsw i32 32, %#15\n  %#17 = lshr i32 %#13, %#16\n  %#18 = or i32 %#12, %#17\n  ret i32 %#18\n}\n=>\ndefine i32 @f1(i32 noundef %#0, i8 noundef %#1) {\n#2:\n  %#3 = zext i8 noundef %#1 to i32\n  %#4 = srem i32 %#3, 32\n  %#5 = trunc i32 %#4 to i8\n  %#6 = zext i8 %#5 to i32\n  %#7 = shl i32 noundef %#0, %#6\n  %#8 = zext i8 noundef %#1 to i32\n  %#9 = sub nsw i32 32, %#8\n  %#10 = lshr i32 noundef %#0, %#9\n  %#11 = or i32 %#7, %#10\n  ret i32 %#11\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\ni32 noundef %#0 = #x00000003 (3)\ni8 noundef %#1 = #xc2 (194, -62)\n\nSource:\nptr %#3 = pointer(local, block_id=0, offset=0) / Address=#x130\nptr %#4 = pointer(local, block_id=1, offset=0) / Address=#x100\ni8 %#5 = #xc2 (194, -62)\ni32 %#6 = #x000000c2 (194)\ni32 %#7 = #x00000002 (2)\ni8 %#8 = #x02 (2)\ni32 %#9 = #x00000003 (3)\ni8 %#10 = #x02 (2)\ni32 %#11 = #x00000002 (2)\ni32 %#12 = #x0000000c (12)\ni32 %#13 = #x00000003 (3)\ni8 %#14 = #x02 (2)\ni32 %#15 = #x00000002 (2)\ni32 %#16 = #x0000001e (30)\ni32 %#17 = #x00000000 (0)\ni32 %#18 = #x0000000c (12)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\talive: true\n\nLOCAL BLOCKS:\nBlock 2 >\tsize: 4\talign: 4\talloc type: 1\talive: true\taddress: 304\nBlock 3 >\tsize: 1\talign: 1\talloc type: 1\talive: true\taddress: 256\n\nTarget:\ni32 %#3 = #x000000c2 (194)\ni32 %#4 = #x00000002 (2)\ni8 %#5 = #x02 (2)\ni32 %#6 = #x00000002 (2)\ni32 %#7 = #x0000000c (12)\ni32 %#8 = #x000000c2 (194)\ni32 %#9 = #xffffff5e (4294967134, -162)\ni32 %#10 = poison\ni32 %#11 = poison\nSource value: #x0000000c (12)\nTarget value: poison\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 32,
    "tgt_latency": 32,
    "src_size": 124,
    "tgt_size": 124,
    "src_inst": 20,
    "tgt_inst": 20
  },
  "24": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpzr34z5u3.ll'\n/tmp/tmpzr34z5u3.ll:42:1: error: expected top-level entity\nEOF\n^",
    "src_latency": 19,
    "tgt_latency": 19,
    "src_size": 160,
    "tgt_size": 160,
    "src_inst": 18,
    "tgt_inst": 18
  },
  "25": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare i32 @foo(...)\ndeclare i32 @bar(...)\ndeclare i32 @baz(...)\n\n@foo = constant ? bytes, exec, align 8\n@bar = constant ? bytes, exec, align 8\n@baz = constant ? bytes, exec, align 8\n\ndefine i32 @main(i32 noundef %#0) {\n#1:\n  %#2 = alloca i64 4, align 4\n  %#3 = alloca i64 4, align 4\n  %#4 = alloca i64 4, align 4\n  %#5 = alloca i64 4, align 4\n  %#6 = alloca i64 4, align 4\n  store i32 0, ptr %#2, align 4\n  store i32 noundef %#0, ptr %#3, align 4\n  %#7 = load i32, ptr %#3, align 4\n  %#8 = call i32 @foo(...noundef i32 %#7)\n  store i32 %#8, ptr %#4, align 4\n  %#9 = load i32, ptr %#3, align 4\n  %#10 = call i32 @bar(...noundef i32 %#9)\n  store i32 %#10, ptr %#5, align 4\n  %#11 = load i32, ptr %#3, align 4\n  %#12 = call i32 @baz(...noundef i32 %#11)\n  store i32 %#12, ptr %#6, align 4\n  %#13 = load i32, ptr %#4, align 4\n  %#14 = load i32, ptr %#6, align 4\n  %#15 = add nsw i32 %#13, %#14\n  ret i32 %#15\n}\n=>\ndeclare i32 @foo(...)\ndeclare i32 @bar(...)\ndeclare i32 @baz(...)\n\n@foo = constant ? bytes, exec, align 8\n@bar = constant ? bytes, exec, align 8\n@baz = constant ? bytes, exec, align 8\n\ndefine i32 @main(i32 noundef %#0) {\n#1:\n  %#2 = call i32 @foo(...noundef i32 noundef %#0)\n  %#3 = call i32 @bar(...noundef i32 noundef %#0)\n  %#4 = call i32 @baz(...noundef i32 noundef %#0)\n  %#5 = add nsw i32 %#2, %#4\n  ret i32 %#5\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 33,
    "tgt_latency": 8,
    "src_size": 144,
    "tgt_size": 132,
    "src_inst": 20,
    "tgt_inst": 5
  },
  "26": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmpgn50znpi.ll'\n/tmp/tmpgn50znpi.ll:27:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 2,
    "tgt_latency": 2,
    "src_size": 68,
    "tgt_size": 68,
    "src_inst": 3,
    "tgt_inst": 3
  },
  "27": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmp_6kazghb.ll'\n/tmp/tmp_6kazghb.ll:27:1: error: expected top-level entity\nunwrap\n^",
    "src_latency": 15,
    "tgt_latency": 15,
    "src_size": 92,
    "tgt_size": 92,
    "src_inst": 9,
    "tgt_inst": 9
  },
  "28": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmp32z7ydsw.ll'\n/tmp/tmp32z7ydsw.ll:29:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 2,
    "tgt_latency": 2,
    "src_size": 68,
    "tgt_size": 68,
    "src_inst": 3,
    "tgt_inst": 3
  },
  "29": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmph23miw2i.ll'\n/tmp/tmph23miw2i.ll:28:1: error: expected top-level entity\nanswer\n^",
    "src_latency": 12,
    "tgt_latency": 12,
    "src_size": 80,
    "tgt_size": 80,
    "src_inst": 8,
    "tgt_inst": 8
  },
  "30": {
    "status": "correct",
    "alive_summary": "----------------------------------------\ndeclare void @mbedtls_zeroize(noundef ptr, noundef i64)\ndeclare void @free(noundef ptr)\n\ndefine void @rsa_alt_free_wrap(ptr noundef %#0) {\n#1:\n  %#2 = alloca i64 8, align 8\n  store ptr noundef %#0, ptr %#2, align 8\n  %#3 = load ptr, ptr %#2, align 8\n  call void @mbedtls_zeroize(noundef ptr %#3, noundef i64 32)\n  %#4 = load ptr, ptr %#2, align 8\n  call void @free(noundef allocptr ptr %#4) nothrow willreturn alloc-family(malloc) allockind(free) memory(inaccessiblemem: readwrite)\n  ret void\n}\n=>\ndeclare void @mbedtls_zeroize(noundef ptr, noundef i64)\ndeclare void @free(noundef ptr)\n\ndefine void @rsa_alt_free_wrap(ptr noundef %#0) {\n#1:\n  call void @mbedtls_zeroize(noundef ptr noundef %#0, noundef i64 32)\n  call void @free(noundef allocptr ptr noundef %#0) nothrow willreturn alloc-family(malloc) allockind(free) memory(inaccessiblemem: readwrite)\n  ret void\n}\nTransformation seems to be correct!\n\nSummary:\n  1 correct transformations\n  0 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors",
    "src_latency": 15,
    "tgt_latency": 6,
    "src_size": 116,
    "tgt_size": 112,
    "src_inst": 7,
    "tgt_inst": 3
  },
  "31": {
    "status": "syntactic error",
    "alive_summary": "Could not read bitcode from '/tmp/tmprqe7z8qa.ll'\n/tmp/tmprqe7z8qa.ll:27:1: error: expected top-level entity\nend answer\n^",
    "src_latency": 7,
    "tgt_latency": 7,
    "src_size": 76,
    "tgt_size": 76,
    "src_inst": 5,
    "tgt_inst": 5
  }
}